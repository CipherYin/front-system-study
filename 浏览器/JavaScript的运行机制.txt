V8引擎： Google的V8引擎是Javascript的一个流行示例； 在Chrome和Node.js中使用V8引擎

    V8引擎主要由两个主要部件组成： 内存堆（empory Heap）- 内存分配地址的地方； Call Stack(调用堆栈)-代码执行的地方

Runtime(运行时)： 有些浏览器的 API 经常被使用到(比如说：setTimeout)，但是，这些 API 却不是引擎提供的。那么，他们是从哪儿来的呢？事实上这里面实际情况有点复杂。所以说我们还有很多引擎之外的 API，
                我们把这些称为浏览器提供 API 称为 Web API，比如说 DOM、AJAX、setTimeout等等。然后我们还拥有如此流行的事件循环和回调队列。


调用栈：JavaScript是一种单线程编程语言，这意味着它只有一个调用堆栈。因此，它一次只能做一件事。调用栈是一种数据结构，它记录了我们在程序中的位置。
        如果我们运行到一个函数，它就会将其放置到栈顶，当从这个函数返回的时候，就会将这个函数从栈顶弹出，这就是调用栈做的事情。每一个进入调用栈的都称为调用帧。


在单个线程上运行代码很容易，因为你不必处理在多线程环境中出现的复杂场景——例如死锁。
但是在一个线程上运行也非常有限制，由于 JavaScript 只有一个调用堆栈，当某段代码运行变慢时会发生什么?


并发与事件循环： 当调用堆栈中的函数调用需要花费大量时间来处理时会发生什么情况? 例如，假设你希望在浏览器中使用JavaScript进行一些复杂的图像转换。
                你可能会问-为什么这是一个问题?问题是，当调用堆栈有函数要执行时，浏览器实际上不能做任何其他事情——它被阻塞了，
                这意味着浏览器不能呈现，它不能运行任何其他代码，它只是卡住了，如果你想在应用中使用流畅的页面效果，这就会产生问题。

                而且这不是唯一的问题，一旦你的浏览器开始处理调用栈中的众多任务，它可能会停止响应相当长一段时间。大多数浏览器都会这么做，报一个错误，询问你是否想终止 web 页面。
                这并不是最好的用户体验，不是吗?

           那么，我们怎样才能在不阻塞UI和不使浏览器失去响应的情况下执行大量代码呢?解决方案是异步回调。

  你可能在单个.js文件中编写 JavaScript 应用程序，但可以肯定的是，你的程序由几个块组成，其中只有一个正在执行，其余的将在稍后执行。最常见的块单元是函数。

大多数刚接触JavaScript的开发人员似乎都有这样的问题，就是认为所有函数都是同步完成，没有考虑的异步的情况。如下例子
    你可能知道标准 Ajax 请求不是同步完成的，这说明在代码执行时 Ajax(..) 函数还没有返回任何值来分配给变量 response。
    一种等待异步函数返回的结果简单的方式就是 回调函数：
注意:实际上可以设置同步Ajax请求，但永远不要那样做。如果设置同步Ajax请求，应用程序的界面将被阻塞——用户将无法单击、输入数据、导航或滚动。这将阻止任何用户交互，这是一种可怕的做法。

这里使用Ajax请求作为示例，你可以让任何代码块异步执行。

这可以通过 setTimeout(callback，milliseconds) 函数来完成。setTimeout 函数的作用是设置一个回调函数milliseconds后执行，如下：
        function first() {
            console.log('first');
        }
        function second() {
            console.log('second');
        }
        function third() {
            console.log('third');
        }
        first();
        setTimeout(second, 1000); // Invoke `second` after 1000ms
        third();
解析事件循环：
    这里从一个有点奇怪的声明开始——尽管允许异步 JavaScript 代码(就像上例讨论的setTimeout)，但在ES6之前，JavaScript本身实际上从来没有任何内置异步的概念，JavaScript引擎在任何给定时刻只执行一个块。

    那么，是谁告诉JS引擎执行程序的代码块呢?实际上，JS引擎并不是单独运行的——它是在一个宿主环境中运行的，对于大多数开发人员来说，宿主环境就是典型的web浏览器或Node.js。实际上，现在JavaScript被嵌入到各种各样的设备中，从机器人到灯泡，每个设备代表 JS 引擎的不同类型的托管环境。
    
    所有环境中的共同点是一个称为事件循环的内置机制，它处理程序的多个块在一段时间内通过调用调用JS引擎的执行。

    这意味着JS引擎只是任意JS代码的按需执行环境，是宿主环境处理事件运行及结果。

    例如，当 JavaScript 程序发出 Ajax 请求从服务器获取一些数据时，在函数(“回调”)中设置“response”代码，JS引擎告诉宿主环境:"我现在要推迟执行，但当完成那个网络请求时，会返回一些数据，请回调这个函数并给数据传给它"。

    然后浏览器将侦听来自网络的响应，当监听到网络请求返回内容时，浏览器通过将回调函数插入事件循环来调度要执行的回调函数。以下是示意图：